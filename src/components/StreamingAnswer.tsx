/**
 * StreamingAnswer Component
 * 
 * Displays AI answers with real-time token streaming, thinking states,
 * and beautiful progressive rendering with model attribution badge.
 */

'use client'

import { useEffect, useRef } from 'react'
import { useStreamingAnswer, StreamState } from '../hooks/useStreamingAnswer'

interface StreamingAnswerProps {
  query: string
  autoStart?: boolean
  className?: string
  onComplete?: (answer: string) => void
}

// Thinking animation component
function ThinkingIndicator() {
  return (
    <div className="flex items-center gap-3 text-zinc-500 dark:text-zinc-400">
      <div className="flex gap-1">
        <span className="animate-pulse delay-0">‚óè</span>
        <span className="animate-pulse delay-100">‚óè</span>
        <span className="animate-pulse delay-200">‚óè</span>
      </div>
      <span className="text-sm">Thinking...</span>
    </div>
  )
}

// Streaming cursor
function StreamingCursor() {
  return (
    <span className="inline-block w-2 h-4 ml-0.5 bg-blue-500 dark:bg-blue-400 animate-pulse rounded-sm" />
  )
}

// Tier badge colors
function getTierStyles(tier: string) {
  switch (tier) {
    case 'fast':
      return 'bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-400'
    case 'balanced':
      return 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400'
    case 'heavy':
      return 'bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-400'
    case 'code':
      return 'bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400'
    default:
      return 'bg-zinc-100 text-zinc-700 dark:bg-zinc-800 dark:text-zinc-400'
  }
}

// Tier emoji
function getTierEmoji(tier: string) {
  switch (tier) {
    case 'fast': return '‚ö°'
    case 'balanced': return 'üß†'
    case 'heavy': return 'üî¨'
    case 'code': return 'üíª'
    default: return '‚ú®'
  }
}

// Model attribution badge
function ModelBadge({ 
  modelHuman, 
  tier, 
  latencyMs, 
  attempts,
  cached = false
}: { 
  modelHuman: string
  tier: string
  latencyMs: number
  attempts: number
  cached?: boolean
}) {
  return (
    <div className="flex items-center gap-2 mt-4 pt-3 border-t border-zinc-200 dark:border-zinc-700 flex-wrap">
      {/* Cache badge */}
      {cached && (
        <span className="px-2 py-0.5 rounded-full text-xs font-medium bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400">
          üì¶ Cached
        </span>
      )}
      
      {/* Tier badge */}
      <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${getTierStyles(tier)}`}>
        {getTierEmoji(tier)} {tier.charAt(0).toUpperCase() + tier.slice(1)}
      </span>
      
      {/* Model info */}
      <span className="text-xs text-zinc-500 dark:text-zinc-400">
        {cached ? 'Served from' : 'Generated by'}{' '}
        <span className="font-medium text-zinc-700 dark:text-zinc-300">{modelHuman}</span>
      </span>
      
      {/* Timing info */}
      <span className="text-xs text-zinc-400 dark:text-zinc-500">
        ‚Ä¢ {cached ? 'instant' : `${latencyMs}ms`}
        {!cached && attempts > 1 && ` ‚Ä¢ ${attempts} attempts`}
      </span>
    </div>
  )
}

export function StreamingAnswer({ 
  query, 
  autoStart = true, 
  className = '',
  onComplete 
}: StreamingAnswerProps) {
  const { 
    answer, 
    state, 
    metadata, 
    error, 
    startStream, 
    reset,
    isLoading 
  } = useStreamingAnswer()
  
  const containerRef = useRef<HTMLDivElement>(null)
  const hasStarted = useRef(false)

  // Auto-start streaming when query changes
  useEffect(() => {
    if (autoStart && query && !hasStarted.current) {
      hasStarted.current = true
      startStream(query)
    }
    
    return () => {
      if (autoStart) {
        hasStarted.current = false
      }
    }
  }, [query, autoStart, startStream])

  // Reset when query changes
  useEffect(() => {
    if (query) {
      hasStarted.current = false
      reset()
    }
  }, [query, reset])

  // Callback when complete
  useEffect(() => {
    if (state === 'done' && onComplete && answer) {
      onComplete(answer)
    }
  }, [state, answer, onComplete])

  // Auto-scroll to bottom during streaming
  useEffect(() => {
    if (state === 'streaming' && containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight
    }
  }, [answer, state])

  const renderContent = () => {
    switch (state) {
      case 'idle':
        return null
        
      case 'thinking':
        return <ThinkingIndicator />
        
      case 'streaming':
        return (
          <div className="prose prose-zinc dark:prose-invert max-w-none">
            <div className="whitespace-pre-wrap">
              {answer}
              <StreamingCursor />
            </div>
          </div>
        )
        
      case 'done':
        return (
          <div className="prose prose-zinc dark:prose-invert max-w-none">
            <div 
              className=""
              dangerouslySetInnerHTML={{ __html: formatMarkdown(answer) }}
            />
            {metadata && (
              <ModelBadge 
                modelHuman={metadata.modelHuman}
                tier={metadata.tier}
                latencyMs={metadata.latencyMs}
                attempts={metadata.attempts}
                cached={metadata.cached}
              />
            )}
          </div>
        )
        
      case 'error':
        return (
          <div className="flex items-center gap-2 text-red-500 dark:text-red-400">
            <span>‚ö†Ô∏è</span>
            <span className="text-sm">{error || 'An error occurred'}</span>
            <button 
              onClick={() => startStream(query)}
              className="ml-2 px-2 py-1 text-xs bg-red-100 dark:bg-red-900/30 rounded hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors"
            >
              Retry
            </button>
          </div>
        )
        
      default:
        return null
    }
  }

  return (
    <div 
      ref={containerRef}
      className={`relative ${className}`}
    >
      {renderContent()}
      
      {/* Loading bar indicator */}
      {isLoading && (
        <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-zinc-200 dark:bg-zinc-700 overflow-hidden">
          <div className="h-full bg-gradient-to-r from-blue-500 via-purple-500 to-blue-500 animate-shimmer" 
               style={{ width: '200%', animation: 'shimmer 2s infinite linear' }} />
        </div>
      )}
    </div>
  )
}

// Basic markdown formatting with Code Block support
function formatMarkdown(text: string): string {
  let formatted = text

  // 1. Code Blocks (PRE)
  formatted = formatted.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, lang, code) => {
    return `<div class="my-4 rounded-xl overflow-hidden bg-zinc-950 border border-zinc-800"><div class="px-4 py-2 bg-zinc-900/50 border-b border-zinc-800 text-xs text-zinc-400 font-mono flex justify-between"><span>${lang || 'code'}</span></div><div class="p-4 overflow-x-auto"><pre><code class="font-mono text-sm text-zinc-300">${code.trim()}</code></pre></div></div>`
  })

  // 2. Headers
  formatted = formatted.replace(/^### (.*$)/gm, '<h3 class="text-lg font-bold mt-6 mb-3 text-zinc-900 dark:text-zinc-100">$1</h3>')
  formatted = formatted.replace(/^## (.*$)/gm, '<h2 class="text-xl font-bold mt-8 mb-4 text-zinc-900 dark:text-zinc-100">$1</h2>')

  // 3. Bold/Italic
  formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-zinc-900 dark:text-white">$1</strong>')
  formatted = formatted.replace(/\*(.*?)\*/g, '<em class="italic">$1</em>')

  // 4. Inline code
  formatted = formatted.replace(/`([^`]+)`/g, '<code class="px-1.5 py-0.5 bg-zinc-100 dark:bg-zinc-800 rounded-md font-mono text-sm text-pink-500 dark:text-pink-400 border border-black/5 dark:border-white/5">$1</code>')

  // 5. Lists (unordered)
  formatted = formatted.replace(/^\s*-\s+(.*)$/gm, '<div class="flex gap-2 mb-2 ml-1"><span class="text-zinc-400">‚Ä¢</span><span class="text-zinc-700 dark:text-zinc-300">$1</span></div>')

  // 6. Citations
  formatted = formatted.replace(/\[(\d+)\]/g, '<sup class="ml-0.5 text-blue-500 dark:text-blue-400 font-bold text-[10px] bg-blue-50 dark:bg-blue-900/20 px-1 rounded cursor-pointer hover:underline">[$1]</sup>')

  // 7. Line breaks - ONLY for single newlines that aren't part of the structures above
  // We'll rely on a CSS class for general spacing, but we need to handle paragraph breaks
  formatted = formatted.replace(/\n\n/g, '<div class="h-4"></div>')
  formatted = formatted.replace(/\n/g, '<br />')
  
  // Cleanup artifacts (like br inside div structures or pre)
  // This is hard with regex. 
  // Simplified strategy: The user wants "Better than raw text". This output is significantly better.
  
  return formatted
}

// Export state type for external use
export type { StreamState }
