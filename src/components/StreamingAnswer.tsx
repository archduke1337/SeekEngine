/**
 * StreamingAnswer Component
 * 
 * Displays AI answers with real-time token streaming, thinking states,
 * and beautiful progressive rendering with model attribution badge.
 */

'use client'

import { useEffect, useRef } from 'react'
import { useStreamingAnswer, StreamState } from '../hooks/useStreamingAnswer'

interface StreamingAnswerProps {
  query: string
  autoStart?: boolean
  className?: string
  onComplete?: (answer: string) => void
}

// Thinking animation component
function ThinkingIndicator() {
  return (
    <div className="flex items-center gap-3 text-zinc-500 dark:text-zinc-400">
      <div className="flex gap-1">
        <span className="animate-pulse delay-0">‚óè</span>
        <span className="animate-pulse delay-100">‚óè</span>
        <span className="animate-pulse delay-200">‚óè</span>
      </div>
      <span className="text-sm">Thinking...</span>
    </div>
  )
}

// Streaming cursor
function StreamingCursor() {
  return (
    <span className="inline-block w-2 h-4 ml-0.5 bg-blue-500 dark:bg-blue-400 animate-pulse rounded-sm" />
  )
}

// Tier badge colors
function getTierStyles(tier: string) {
  switch (tier) {
    case 'fast':
      return 'bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-400'
    case 'balanced':
      return 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400'
    case 'heavy':
      return 'bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-400'
    case 'code':
      return 'bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400'
    default:
      return 'bg-zinc-100 text-zinc-700 dark:bg-zinc-800 dark:text-zinc-400'
  }
}

// Tier emoji
function getTierEmoji(tier: string) {
  switch (tier) {
    case 'fast': return '‚ö°'
    case 'balanced': return 'üß†'
    case 'heavy': return 'üî¨'
    case 'code': return 'üíª'
    default: return '‚ú®'
  }
}

// Model attribution badge
function ModelBadge({ 
  modelHuman, 
  tier, 
  latencyMs, 
  attempts 
}: { 
  modelHuman: string
  tier: string
  latencyMs: number
  attempts: number
}) {
  return (
    <div className="flex items-center gap-2 mt-4 pt-3 border-t border-zinc-200 dark:border-zinc-700">
      <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${getTierStyles(tier)}`}>
        {getTierEmoji(tier)} {tier.charAt(0).toUpperCase() + tier.slice(1)}
      </span>
      <span className="text-xs text-zinc-500 dark:text-zinc-400">
        Generated by <span className="font-medium text-zinc-700 dark:text-zinc-300">{modelHuman}</span>
      </span>
      <span className="text-xs text-zinc-400 dark:text-zinc-500">
        ‚Ä¢ {latencyMs}ms
        {attempts > 1 && ` ‚Ä¢ ${attempts} attempts`}
      </span>
    </div>
  )
}

export function StreamingAnswer({ 
  query, 
  autoStart = true, 
  className = '',
  onComplete 
}: StreamingAnswerProps) {
  const { 
    answer, 
    state, 
    metadata, 
    error, 
    startStream, 
    reset,
    isLoading 
  } = useStreamingAnswer()
  
  const containerRef = useRef<HTMLDivElement>(null)
  const hasStarted = useRef(false)

  // Auto-start streaming when query changes
  useEffect(() => {
    if (autoStart && query && !hasStarted.current) {
      hasStarted.current = true
      startStream(query)
    }
    
    return () => {
      if (autoStart) {
        hasStarted.current = false
      }
    }
  }, [query, autoStart, startStream])

  // Reset when query changes
  useEffect(() => {
    if (query) {
      hasStarted.current = false
      reset()
    }
  }, [query, reset])

  // Callback when complete
  useEffect(() => {
    if (state === 'done' && onComplete && answer) {
      onComplete(answer)
    }
  }, [state, answer, onComplete])

  // Auto-scroll to bottom during streaming
  useEffect(() => {
    if (state === 'streaming' && containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight
    }
  }, [answer, state])

  const renderContent = () => {
    switch (state) {
      case 'idle':
        return null
        
      case 'thinking':
        return <ThinkingIndicator />
        
      case 'streaming':
        return (
          <div className="prose prose-zinc dark:prose-invert max-w-none">
            <div className="whitespace-pre-wrap">
              {answer}
              <StreamingCursor />
            </div>
          </div>
        )
        
      case 'done':
        return (
          <div className="prose prose-zinc dark:prose-invert max-w-none">
            <div 
              className="whitespace-pre-wrap"
              dangerouslySetInnerHTML={{ __html: formatMarkdown(answer) }}
            />
            {metadata && (
              <ModelBadge 
                modelHuman={metadata.modelHuman}
                tier={metadata.tier}
                latencyMs={metadata.latencyMs}
                attempts={metadata.attempts}
              />
            )}
          </div>
        )
        
      case 'error':
        return (
          <div className="flex items-center gap-2 text-red-500 dark:text-red-400">
            <span>‚ö†Ô∏è</span>
            <span className="text-sm">{error || 'An error occurred'}</span>
            <button 
              onClick={() => startStream(query)}
              className="ml-2 px-2 py-1 text-xs bg-red-100 dark:bg-red-900/30 rounded hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors"
            >
              Retry
            </button>
          </div>
        )
        
      default:
        return null
    }
  }

  return (
    <div 
      ref={containerRef}
      className={`relative ${className}`}
    >
      {renderContent()}
      
      {/* Loading bar indicator */}
      {isLoading && (
        <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-zinc-200 dark:bg-zinc-700 overflow-hidden">
          <div className="h-full bg-gradient-to-r from-blue-500 via-purple-500 to-blue-500 animate-shimmer" 
               style={{ width: '200%', animation: 'shimmer 2s infinite linear' }} />
        </div>
      )}
    </div>
  )
}

// Simple markdown formatter (basic support)
function formatMarkdown(text: string): string {
  return text
    // Bold
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // Italic
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    // Inline code
    .replace(/`([^`]+)`/g, '<code class="px-1 py-0.5 bg-zinc-100 dark:bg-zinc-800 rounded text-sm">$1</code>')
    // Citations [1], [2]
    .replace(/\[(\d+)\]/g, '<sup class="text-blue-500 dark:text-blue-400 cursor-pointer hover:underline">[$1]</sup>')
    // Line breaks
    .replace(/\n/g, '<br />')
}

// Export state type for external use
export type { StreamState }
