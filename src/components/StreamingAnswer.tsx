/**
 * StreamingAnswer Component
 * 
 * Displays AI answers with real-time token streaming, thinking states,
 * and beautiful progressive rendering with model attribution badge.
 */

'use client'

import { useEffect, useRef, useState } from 'react'
import { useStreamingAnswer, StreamState } from '../hooks/useStreamingAnswer'

interface StreamingAnswerProps {
  query: string
  autoStart?: boolean
  className?: string
  onComplete?: (answer: string) => void
}

// Thinking animation component
function ThinkingIndicator() {
  const [visible, setVisible] = useState(false)
  
  // Perceptual Polish: Only show thinking after 150ms to avoid flicker on fast responses
  useEffect(() => {
    const timer = setTimeout(() => setVisible(true), 150)
    return () => clearTimeout(timer)
  }, [])

  if (!visible) return null

  return (
    <div className="flex items-center gap-3 text-zinc-500 dark:text-zinc-400">
      <div className="flex gap-1">
        <span className="animate-pulse delay-0">‚óè</span>
        <span className="animate-pulse delay-100">‚óè</span>
        <span className="animate-pulse delay-200">‚óè</span>
      </div>
      <span className="text-sm">Thinking...</span>
    </div>
  )
}

// Streaming cursor
function StreamingCursor() {
  return (
    <span className="inline-block w-2 h-4 ml-0.5 bg-blue-500 dark:bg-blue-400 animate-pulse rounded-sm align-middle" />
  )
}

// Tier badge colors
function getTierStyles(tier: string) {
  switch (tier) {
    case 'fast':
      return 'bg-emerald-100 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-400'
    case 'balanced':
      return 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400'
    case 'heavy':
      return 'bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-400'
    case 'code':
      return 'bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400'
    default:
      return 'bg-zinc-100 text-zinc-700 dark:bg-zinc-800 dark:text-zinc-400'
  }
}

// Tier emoji
function getTierEmoji(tier: string) {
  switch (tier) {
    case 'fast': return '‚ö°'
    case 'balanced': return 'üß†'
    case 'heavy': return 'üî¨'
    case 'code': return 'üíª'
    default: return '‚ú®'
  }
}

// Model attribution badge
function ModelBadge({ 
  modelHuman, 
  tier, 
  latencyMs, 
  attempts,
  cached = false
}: { 
  modelHuman: string
  tier: string
  latencyMs: number
  attempts: number
  cached?: boolean
}) {
  return (
    <div className="flex items-center gap-2 mt-4 pt-3 border-t border-zinc-200 dark:border-zinc-700 flex-wrap">
      {/* Cache badge */}
      {cached && (
        <span className="px-2 py-0.5 rounded-full text-xs font-medium bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400">
          üì¶ Cached
        </span>
      )}
      
      {/* Tier badge */}
      <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${getTierStyles(tier)}`}>
        {getTierEmoji(tier)} {tier.charAt(0).toUpperCase() + tier.slice(1)}
      </span>
      
      {/* Model info */}
      <span className="text-xs text-zinc-500 dark:text-zinc-400">
        {cached ? 'Served from' : 'Generated by'}{' '}
        <span className="font-medium text-zinc-700 dark:text-zinc-300">{modelHuman}</span>
      </span>
      
      {/* Timing info */}
      <span className="text-xs text-zinc-400 dark:text-zinc-500">
        ‚Ä¢ {cached ? 'instant' : `${latencyMs}ms TTFT`}
        {!cached && attempts > 1 && ` ‚Ä¢ ${attempts} attempts`}
      </span>
    </div>
  )
}

export function StreamingAnswer({ 
  query, 
  autoStart = true, 
  className = '',
  onComplete 
}: StreamingAnswerProps) {
  const { 
    answer, 
    state, 
    metadata, 
    error, 
    startStream, 
    reset,
    isLoading 
  } = useStreamingAnswer()
  
  const containerRef = useRef<HTMLDivElement>(null)
  const lastStartedQuery = useRef<string | null>(null)
  const completed = useRef(false)
  const shouldAutoScroll = useRef(true)

  // Standard Streaming UX: Only auto-scroll if user is near the bottom
  useEffect(() => {
    const el = containerRef.current
    if (!el) return

    const onScroll = () => {
      // Threshold of 40px from bottom to consider "at bottom"
      shouldAutoScroll.current = el.scrollHeight - el.scrollTop - el.clientHeight < 40
    }

    el.addEventListener('scroll', onScroll)
    return () => el.removeEventListener('scroll', onScroll)
  }, [])

  // Consolidated Lifecycle Effect
  useEffect(() => {
    if (autoStart && query && lastStartedQuery.current !== query) {
      lastStartedQuery.current = query
      completed.current = false
      startStream(query)
    }
  }, [query, autoStart, startStream])

  // Lifecycle Callback Guard: Prevents double-fire if state re-paints
  useEffect(() => {
    if (state === 'done' && onComplete && answer && !completed.current) {
      completed.current = true
      onComplete(answer)
    }
  }, [state, answer, onComplete])

  // Intelligent Auto-scroll
  useEffect(() => {
    if (state === 'streaming' && containerRef.current && shouldAutoScroll.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight
    }
  }, [answer, state])

  const renderContent = () => {
    switch (state) {
      case 'idle':
        return null
        
      case 'thinking':
        return <ThinkingIndicator />
        
      case 'streaming':
        return (
          <div className="w-full max-w-none">
            <div className="whitespace-pre-wrap text-zinc-800 dark:text-zinc-200">
              {answer}
              {/* Avoid cursor drop if ending with newline */}
              {!answer.endsWith('\n') && <StreamingCursor />}
            </div>
          </div>
        )
        
      case 'done':
        return (
          <div className="w-full max-w-none">
            <div 
              className="prose prose-zinc dark:prose-invert max-w-none"
              dangerouslySetInnerHTML={{ 
                __html: formatMarkdown(answer) || '<p class="text-zinc-400 italic">No content generated.</p>' 
              }}
            />
            {metadata && (
              <ModelBadge 
                modelHuman={metadata.modelHuman}
                tier={metadata.tier}
                latencyMs={metadata.latencyMs}
                attempts={metadata.attempts}
                cached={metadata.cached}
              />
            )}
          </div>
        )
        
      case 'error':
        return (
          <div className="flex items-center gap-2 text-red-500 dark:text-red-400">
            <span>‚ö†Ô∏è</span>
            <span className="text-sm">{error || 'An error occurred'}</span>
            <button 
              onClick={() => {
                completed.current = false
                startStream(query)
              }}
              className="ml-2 px-2 py-1 text-xs bg-red-100 dark:bg-red-900/30 rounded hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors"
            >
              Retry
            </button>
          </div>
        )
        
      default:
        return null
    }
  }

  return (
    <div 
      ref={containerRef}
      className={`relative ${className}`}
    >
      {renderContent()}
      
      {/* Loading bar indicator */}
      {isLoading && (
        <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-zinc-200 dark:bg-zinc-700 overflow-hidden rounded-full">
          <div className="h-full w-full bg-gradient-to-r from-blue-500/0 via-blue-500 to-blue-500/0 animate-shimmer" />
        </div>
      )}
    </div>
  )
}

function escapeHTML(str: string) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}

// Basic markdown formatting with Code Block support & Security Sanitization
function formatMarkdown(text: string): string {
  // 0. Security First: Escape HTML before any transformations to prevent XSS
  let formatted = escapeHTML(text)

  // 1. Code Blocks (PRE) - Extract and protect
  formatted = formatted.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, lang, code) => {
    return `<div class="my-4 rounded-xl overflow-hidden bg-zinc-950 border border-zinc-800"><div class="px-4 py-2 bg-zinc-900/50 border-b border-zinc-800 text-xs text-zinc-400 font-mono flex justify-between"><span>${lang || 'code'}</span></div><div class="p-4 overflow-x-auto"><pre><code class="font-mono text-sm text-zinc-300">${code.trim()}</code></pre></div></div>`
  })

  // 2. Headers
  formatted = formatted.replace(/^# (.*$)/gm, '<h1 class="text-2xl font-black mt-4 mb-4 text-black dark:text-white tracking-tighter">$1</h1>')
  formatted = formatted.replace(/^## (.*$)/gm, '<h2 class="text-xl font-extrabold mt-8 mb-4 text-zinc-900 dark:text-zinc-100 tracking-tight">$1</h2>')
  formatted = formatted.replace(/^### (.*$)/gm, '<h3 class="text-lg font-bold mt-6 mb-3 text-zinc-800 dark:text-zinc-200">$1</h3>')

  // 3. Bold/Italic
  formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-zinc-900 dark:text-white">$1</strong>')
  formatted = formatted.replace(/\*(.*?)\*/g, '<em class="italic">$1</em>')

  // 4. Inline code
  formatted = formatted.replace(/`([^`]+)`/g, '<code class="px-1.5 py-0.5 bg-zinc-100 dark:bg-zinc-800 rounded-md font-mono text-sm text-pink-500 dark:text-pink-400 border border-black/5 dark:border-white/5">$1</code>')

  // 5. Lists (unordered)
  formatted = formatted.replace(/^\s*-\s+(.*)$/gm, '<div class="flex gap-2 mb-2 ml-1"><span class="text-zinc-400">‚Ä¢</span><span class="text-zinc-700 dark:text-zinc-300">$1</span></div>')

  // 6. Citations
  formatted = formatted.replace(/\[(\d+)\]/g, '<sup class="ml-0.5 text-blue-500 dark:text-blue-400 font-bold text-[10px] bg-blue-50 dark:bg-blue-900/20 px-1 rounded cursor-pointer hover:underline">[$1]</sup>')

  // 7. Line breaks
  formatted = formatted.replace(/\n\n/g, '<div class="h-4"></div>')
  formatted = formatted.replace(/\n/g, '<br />')
  
  return formatted
}

// Export state type for external use
export type { StreamState }
